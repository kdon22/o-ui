/**
 * üó∫Ô∏è **SIMPLE SOURCE MAP CONSUMER** - Lightweight TypeScript-style consumer
 * 
 * Consumes standard source maps generated by the simple generator.
 * No runtime state tracking, no execution context, no complex mappings.
 * 
 * Follows the exact same pattern as browser DevTools:
 * - Read standard source map JSON
 * - Provide simple line-to-line lookups
 * - Handle your "if any" scenario perfectly
 * - Wire to Monaco debugger (not auto-loading)
 */

import type { SimpleSourceMap } from '@/lib/editor/python-generation/simple-source-map'

export interface SourceMapLookupResult {
  originalLine: number
  originalColumn: number
  sourceFile: string
  confidence: 'high' | 'medium' | 'low'
}

/**
 * üéØ **SIMPLE SOURCE MAP CONSUMER** - Clean, focused consumer
 */
export class SimpleSourceMapConsumer {
  private sourceMap: SimpleSourceMap
  private lineMapping: Map<number, number> = new Map()
  private reverseMapping: Map<number, number[]> = new Map()

  constructor(sourceMap: SimpleSourceMap) {
    this.sourceMap = sourceMap
    this.buildLineMappings()
  }

  /**
   * üîß **BUILD LINE MAPPINGS** - Parse source map into lookup tables
   */
  private buildLineMappings(): void {
    // For now, use simple 1:1 mapping
    // In production, decode VLQ mappings properly
    
    const businessLines = this.sourceMap.sourcesContent[0]?.split('\n') || []
    const pythonContent = this.getPythonContent()
    const pythonLines = pythonContent.split('\n')

    // Build simple line-to-line mappings
    pythonLines.forEach((pythonLine, pythonIndex) => {
      const pythonLineNumber = pythonIndex + 1
      const pythonTrimmed = pythonLine.trim()
      
      // Skip empty lines and comments
      if (!pythonTrimmed || pythonTrimmed.startsWith('#')) {
        return
      }
      
      // üéØ **SIMPLE MAPPING**: Most Python lines map 1:1 to business rules
      const businessLineNumber = Math.min(pythonLineNumber, businessLines.length)
      
      if (businessLineNumber >= 1 && businessLines[businessLineNumber - 1]?.trim()) {
        this.lineMapping.set(pythonLineNumber, businessLineNumber)
        
        // Build reverse mapping
        const existing = this.reverseMapping.get(businessLineNumber) || []
        existing.push(pythonLineNumber)
        this.reverseMapping.set(businessLineNumber, existing)
      }
    })

    // üåä **ENHANCED MAPPING**: Handle "if any" scenarios
    this.buildIfAnyMappings(businessLines, pythonLines)
    
    console.log('‚úÖ [SimpleSourceMapConsumer] Line mappings built:', {
      forwardMappings: this.lineMapping.size,
      reverseMappings: this.reverseMapping.size,
      businessLines: businessLines.length,
      pythonLines: pythonLines.length
    })
  }

  /**
   * üåä **BUILD "IF ANY" MAPPINGS** - Handle your specific scenario
   */
  private buildIfAnyMappings(businessLines: string[], pythonLines: string[]): void {
    businessLines.forEach((businessLine, businessIndex) => {
      const businessLineNumber = businessIndex + 1
      const trimmed = businessLine.trim()
      
      // üéØ **DETECT "IF ANY" PATTERN**
      if (trimmed.match(/^if\s+any\s+/i)) {
        // Find corresponding Python for-loop
        pythonLines.forEach((pythonLine, pythonIndex) => {
          const pythonLineNumber = pythonIndex + 1
          const pythonTrimmed = pythonLine.trim()
          
          // Map for-loop header to "if any" line
          if (pythonTrimmed.startsWith('for ') && pythonTrimmed.includes(' in ')) {
            this.lineMapping.set(pythonLineNumber, businessLineNumber)
            
            // Update reverse mapping
            const existing = this.reverseMapping.get(businessLineNumber) || []
            if (!existing.includes(pythonLineNumber)) {
              existing.push(pythonLineNumber)
              this.reverseMapping.set(businessLineNumber, existing)
            }
          }
        })
      }
    })
  }

  /**
   * üîç **LOOKUP ORIGINAL LINE** - Python line ‚Üí Business rule line
   * 
   * This is the main function used by the debugger
   */
  getOriginalLine(pythonLine: number): SourceMapLookupResult | null {
    const businessLine = this.lineMapping.get(pythonLine)
    
    if (businessLine) {
      return {
        originalLine: businessLine,
        originalColumn: 1, // Simple column mapping
        sourceFile: this.sourceMap.sources[0] || 'business-rules.txt',
        confidence: 'high'
      }
    }
    
    // üîÑ **FALLBACK**: Simple 1:1 mapping for unmapped lines
    const businessLines = this.sourceMap.sourcesContent[0]?.split('\n') || []
    if (pythonLine >= 1 && pythonLine <= businessLines.length) {
      return {
        originalLine: pythonLine,
        originalColumn: 1,
        sourceFile: this.sourceMap.sources[0] || 'business-rules.txt',
        confidence: 'medium'
      }
    }
    
    return null
  }

  /**
   * üîÑ **LOOKUP GENERATED LINES** - Business rule line ‚Üí Python lines
   * 
   * Used for setting breakpoints in business rules
   */
  getGeneratedLines(businessLine: number): number[] {
    return this.reverseMapping.get(businessLine) || []
  }

  /**
   * üìÑ **GET PYTHON CONTENT** - Extract Python content for analysis
   */
  private getPythonContent(): string {
    // In a full implementation, this would come from the source map
    // For now, we'll need to get it from the debugger context
    return '' // Placeholder - will be provided by the debugger
  }

  /**
   * üìä **GET MAPPING STATS** - Debug information
   */
  getMappingStats(): {
    totalMappings: number
    businessLines: number
    pythonLines: number
    ifAnyMappings: number
  } {
    const businessLines = this.sourceMap.sourcesContent[0]?.split('\n').length || 0
    
    // Count "if any" mappings
    let ifAnyMappings = 0
    this.reverseMapping.forEach((pythonLines, businessLine) => {
      const businessContent = this.sourceMap.sourcesContent[0]?.split('\n')[businessLine - 1] || ''
      if (businessContent.trim().match(/^if\s+any\s+/i)) {
        ifAnyMappings += pythonLines.length
      }
    })
    
    return {
      totalMappings: this.lineMapping.size,
      businessLines,
      pythonLines: 0, // Will be set when Python content is available
      ifAnyMappings
    }
  }

  /**
   * üß™ **TEST MAPPING** - Verify mapping works for your scenario
   */
  testIfAnyScenario(businessRules: string, pythonCode: string): {
    success: boolean
    mappings: Array<{ python: number; business: number; line: string }>
    errors: string[]
  } {
    const errors: string[] = []
    const mappings: Array<{ python: number; business: number; line: string }> = []
    
    try {
      const pythonLines = pythonCode.split('\n')
      
      pythonLines.forEach((pythonLine, pythonIndex) => {
        const pythonLineNumber = pythonIndex + 1
        const result = this.getOriginalLine(pythonLineNumber)
        
        if (result) {
          mappings.push({
            python: pythonLineNumber,
            business: result.originalLine,
            line: pythonLine.trim()
          })
        }
      })
      
      return {
        success: true,
        mappings,
        errors
      }
    } catch (error) {
      errors.push(`Mapping test failed: ${error}`)
      return {
        success: false,
        mappings,
        errors
      }
    }
  }
}

/**
 * üè≠ **FACTORY FUNCTION** - Create consumer from source map
 */
export function createSimpleSourceMapConsumer(sourceMap: SimpleSourceMap): SimpleSourceMapConsumer {
  return new SimpleSourceMapConsumer(sourceMap)
}

/**
 * üîç **QUICK LOOKUP** - Convenience function for single lookups
 */
export function lookupOriginalLine(sourceMap: SimpleSourceMap, pythonLine: number): number | null {
  const consumer = createSimpleSourceMapConsumer(sourceMap)
  const result = consumer.getOriginalLine(pythonLine)
  return result?.originalLine || null
}
