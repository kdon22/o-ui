/**
 * üéØ IF ANY PATTERN - Handles "if any collection has condition" constructs
 * 
 * Transforms: if any testcls in testClasses has testcls.age = 4
 *             ...nested content...
 *             else
 *               air = "RR"
 * 
 * Into:       for testcls in testClasses:
 *                 if testcls.age == 4:
 *                     ...nested content...
 *                 break
 *             else:
 *                 air = "RR"
 */

import type {
  TransformationPattern,
  TransformationResult,
  TransformationContext,
  SpecialMapping,
  TransformationMetadata
} from '../types'
import { SimpleIndentation } from '../../indentation-create'

export class IfAnyPattern implements TransformationPattern {
  id = 'if-any'
  name = 'If Any Collection Pattern'
  description = 'Transforms "if any X in Y has condition" into Python for-loop with break/else'

  /**
   * üîç DETECTOR - Check if line matches "if any" pattern
   */
  detector(line: string): boolean {
    const trimmed = line.trim()
    const hasIfAny = trimmed.startsWith('if any ')
    const hasIn = trimmed.includes(' in ')
    const hasHas = trimmed.includes(' has ')
    const matches = hasIfAny && hasIn && hasHas
    
    console.log(`üîç [IfAnyPattern] Detector analysis:`, {
      line: trimmed,
      hasIfAny,
      hasIn,
      hasHas,
      finalMatch: matches
    })
    
    return matches
  }

  /**
   * üîÑ TRANSFORMER - Convert if any construct to Python using simple indentation
   */
  transformer(line: string, allLines: string[], currentIndex: number): TransformationResult {
    console.log(`üéØ [IfAnyPattern] Using simple indentation approach`)
    
    // Use simple indentation system
    const indentResult = SimpleIndentation.processIfAny(line, allLines, currentIndex)
    
    // Parse for metadata
    const trimmed = line.trim()
    const anyMatch = trimmed.match(/^if\s+any\s+(\w+)\s+in\s+(\w+(?:\.\w+)*)\s+has\s+(.+)/)
    if (!anyMatch) {
      throw new Error(`Invalid if any syntax: ${trimmed}`)
    }

    const [, itemVar, collection, condition] = anyMatch
    
    // üéØ SMART CONDITION PARSING - Handle different "has" patterns
    let pythonCondition: string
    
    // Check if condition already contains the item variable (e.g., "testcls.age = 5")
    if (condition.includes(itemVar)) {
      // Complex condition like "testcls.age = 5" -> "testcls.age == 5"
      pythonCondition = condition
        .replace(/\s*=\s*/g, ' == ')     // = becomes ==
        .replace(/\s*<>\s*/g, ' != ')    // <> becomes !=
    } else {
      // Simple value condition like "1" -> "testcls == 1"
      const translatedCondition = condition
        .replace(/\s*=\s*/g, ' == ')     // = becomes ==
        .replace(/\s*<>\s*/g, ' != ')    // <> becomes !=
      pythonCondition = `${itemVar} == ${translatedCondition}`
    }

    const metadata: TransformationMetadata = {
      type: 'if-any',
      businessLineRange: [currentIndex + 1, currentIndex + indentResult.consumedLines],
      pythonLineRange: [0, 0], // Will be filled by caller
      specialMappings: [], // Will be generated by generateMappings
      context: {
        itemVar,
        collection,
        condition: pythonCondition,
        hasElse: indentResult.consumedLines > 1,
        elseBusinessLine: null, // Will be calculated if needed
        breakInsertionPoint: null,
        forLineIndex: 0,
        ifLineIndex: 1
      }
    }

    // üöÄ DIRECT PYTHON GENERATION - Build the complete Python structure
    const result = this.generateDirectPython(itemVar, collection, pythonCondition, allLines, currentIndex)
    
    console.log(`‚úÖ [IfAnyPattern] Direct Python generation completed:`, {
      pythonLinesCount: result.pythonLines.length,
      consumedLines: result.consumedLines
    })

    return {
      pythonLines: result.pythonLines,
      consumedLines: result.consumedLines,
      metadata
    }
  }

  /**
   * üöÄ GENERATE DIRECT PYTHON - Build complete Python structure directly
   */
  private generateDirectPython(
    itemVar: string, 
    collection: string, 
    pythonCondition: string, 
    allLines: string[], 
    currentIndex: number
  ): { pythonLines: string[], consumedLines: number } {
    console.log(`üîß [IfAnyPattern] Generating direct Python for: ${itemVar} in ${collection}`)
    
    const pythonLines: string[] = []
    let consumedLines = 1 // Start with the if-any line itself
    
    // 1. Generate the for loop header
    pythonLines.push(`for ${itemVar} in ${collection}:`)
    pythonLines.push(`    if ${pythonCondition}:`)
    
    // 2. Process the nested content directly
    let i = currentIndex + 1
    let foundElse = false
    let elseIndentLevel = -1
    
    while (i < allLines.length) {
      const line = allLines[i]
      const trimmed = line.trim()
      const indent = this.getIndentLevel(line)
      
      // Stop if we've reached the end of the if-any block
      if (trimmed && indent === 0) {
        break
      }
      
      // Handle 'else' at the same level as the if-any
      if (trimmed === 'else' && indent === 0) {
        foundElse = true
        elseIndentLevel = 0
        pythonLines.push(`        break`)
        pythonLines.push(`else:`)
        consumedLines++
        i++
        continue
      }
      
      // Handle nested 'else' clauses (internal to the if-any block)
      if (trimmed === 'else' && indent > 0 && !foundElse) {
        // This is an internal else clause - match the indentation level
        const pythonIndent = '        ' + '    '.repeat(Math.max(0, (indent - 4) / 4))
        pythonLines.push(`${pythonIndent}else:`)
        consumedLines++
        i++
        continue
      }
      
      // Handle regular content
      if (trimmed) {
        if (foundElse && elseIndentLevel === 0) {
          // Content after the main else
          const translatedLine = this.translateBusinessRuleLine(trimmed)
          pythonLines.push(`    ${translatedLine}`)
        } else {
          // Content inside the if-any block
          const translatedLine = this.translateBusinessRuleLine(trimmed)
          const pythonIndent = '        ' + '    '.repeat(Math.max(0, (indent - 4) / 4))
          pythonLines.push(`${pythonIndent}${translatedLine}`)
        }
      }
      
      consumedLines++
      i++
    }
    
    // Add break if we haven't added it yet (and we're not in an else block)
    if (!foundElse) {
      pythonLines.push(`        break`)
    }
    
    console.log(`‚úÖ [IfAnyPattern] Generated ${pythonLines.length} Python lines, consumed ${consumedLines} business rule lines`)
    
    return { pythonLines, consumedLines }
  }

  /**
   * üîß HELPER - Get indentation level of a line
   */
  private getIndentLevel(line: string): number {
    const match = line.match(/^(\s*)/)
    return match ? match[1].length : 0
  }

  /**
   * üîß HELPER - Translate a business rule line to Python
   */
  private translateBusinessRuleLine(line: string): string {
    // Handle if statements - convert = to == in conditions
    if (line.trim().startsWith('if ')) {
      return line
        .replace(/\s*=\s*/g, ' == ')     // = becomes == in conditions
        .replace(/\s*<>\s*/g, ' != ')    // <> becomes !=
        + ':'                            // Add colon for Python
    }
    
    // Handle regular assignments and other statements
    return line
      .replace(/\s*<>\s*/g, ' != ')      // <> becomes !=
      // Keep = as = for assignments (don't change to ==)
  }

  /**
   * üó∫Ô∏è GENERATE MAPPINGS - Create source mappings for this transformation
   */
  generateMappings(result: TransformationResult, context: TransformationContext): SpecialMapping[] {
    console.log(`üó∫Ô∏è [IfAnyPattern] Starting mapping generation...`)
    
    const mappings: SpecialMapping[] = []
    const { metadata } = result
    const { context: patternContext } = metadata

    const businessStartLine = metadata.businessLineRange[0]
    const pythonStartLine = context.currentPythonLineOffset

    console.log(`üìä [IfAnyPattern] Mapping context:`, {
      businessStartLine,
      pythonStartLine,
      businessLineRange: metadata.businessLineRange,
      pythonLinesGenerated: result.pythonLines.length,
      hasElse: patternContext.hasElse,
      elseBusinessLine: patternContext.elseBusinessLine
    })

    // 1. Map the "if any" line to the "for" line
    const forMapping = {
      businessLine: businessStartLine,
      pythonLine: pythonStartLine + patternContext.forLineIndex,
      type: 'loop-header' as const,
      confidence: 1.0,
      description: `if any ${patternContext.itemVar} in ${patternContext.collection} ‚Üí for loop`
    }
    mappings.push(forMapping)
    console.log(`üîó [IfAnyPattern] Added for-loop mapping:`, forMapping)

    // 2. Map the "if any" line to the "if" condition line (secondary mapping)
    const conditionMapping = {
      businessLine: businessStartLine,
      pythonLine: pythonStartLine + patternContext.ifLineIndex,
      type: 'condition' as const,
      confidence: 0.9,
      description: `condition: ${patternContext.condition}`
    }
    mappings.push(conditionMapping)
    console.log(`üîó [IfAnyPattern] Added condition mapping:`, conditionMapping)

    // 3. If there's an else clause, create special mappings for break and else
    if (patternContext.hasElse && patternContext.elseBusinessLine) {
      console.log(`üîç [IfAnyPattern] Processing else clause mappings...`)
      
      // The break statement will be inserted before the else
      // This is a generated line that maps to the else business line
      const breakMapping = {
        businessLine: patternContext.elseBusinessLine,
        pythonLine: pythonStartLine + result.pythonLines.length, // Break will be added after nested content
        type: 'break-statement' as const,
        confidence: 0.8,
        description: 'Generated break statement for if-any-else construct'
      }
      mappings.push(breakMapping)
      console.log(`üîó [IfAnyPattern] Added break statement mapping:`, breakMapping)

      // The else clause itself
      const elseMapping = {
        businessLine: patternContext.elseBusinessLine,
        pythonLine: pythonStartLine + result.pythonLines.length + 1, // Else comes after break
        type: 'else-clause' as const,
        confidence: 1.0,
        description: 'else clause for if-any construct'
      }
      mappings.push(elseMapping)
      console.log(`üîó [IfAnyPattern] Added else clause mapping:`, elseMapping)

      console.log(`‚úÖ [IfAnyPattern] Else clause mappings completed. Business line ${patternContext.elseBusinessLine} maps to:`)
      console.log(`   - Break statement at Python line ${breakMapping.pythonLine}`)
      console.log(`   - Else clause at Python line ${elseMapping.pythonLine}`)
    } else {
      console.log(`‚ÑπÔ∏è [IfAnyPattern] No else clause found, skipping else mappings`)
    }

    console.log(`‚úÖ [IfAnyPattern] Mapping generation completed. Total mappings: ${mappings.length}`)
    return mappings
  }

  // Legacy methods removed - now using MonacoStyleIndentation


}
