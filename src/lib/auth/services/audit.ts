// Enterprise Authentication Audit Service
import { prisma } from "@/lib/prisma"
import { headers } from "next/headers"

// TODO: These will be generated by Prisma after schema migration
export enum LoginResult {
  SUCCESS = "SUCCESS",
  FAILED_INVALID_CREDENTIALS = "FAILED_INVALID_CREDENTIALS",
  FAILED_ACCOUNT_LOCKED = "FAILED_ACCOUNT_LOCKED",
  FAILED_ACCOUNT_DISABLED = "FAILED_ACCOUNT_DISABLED",
  FAILED_2FA_REQUIRED = "FAILED_2FA_REQUIRED",
  FAILED_2FA_INVALID = "FAILED_2FA_INVALID",
  FAILED_DEVICE_NOT_TRUSTED = "FAILED_DEVICE_NOT_TRUSTED",
  FAILED_SUSPICIOUS_ACTIVITY = "FAILED_SUSPICIOUS_ACTIVITY",
}

export enum SecurityEventType {
  LOGIN_SUCCESS = "LOGIN_SUCCESS",
  LOGIN_FAILED = "LOGIN_FAILED",
  PASSWORD_CHANGED = "PASSWORD_CHANGED",
  EMAIL_CHANGED = "EMAIL_CHANGED",
  TOTP_ENABLED = "TOTP_ENABLED",
  TOTP_DISABLED = "TOTP_DISABLED",
  TOTP_BACKUP_USED = "TOTP_BACKUP_USED",
  DEVICE_ADDED = "DEVICE_ADDED",
  DEVICE_REMOVED = "DEVICE_REMOVED",
  SUSPICIOUS_LOGIN = "SUSPICIOUS_LOGIN",
  ACCOUNT_LOCKED = "ACCOUNT_LOCKED",
  ACCOUNT_UNLOCKED = "ACCOUNT_UNLOCKED",
  SESSION_EXPIRED = "SESSION_EXPIRED",
  FORCE_LOGOUT = "FORCE_LOGOUT",
}

export enum DeviceType {
  DESKTOP = "DESKTOP",
  MOBILE = "MOBILE",
  TABLET = "TABLET",
  UNKNOWN = "UNKNOWN",
}

export interface LoginAttempt {
  userId?: string
  email: string
  result: LoginResult
  ipAddress?: string
  userAgent?: string
  deviceFingerprint?: string
  failureReason?: string
  location?: string
}

export interface DeviceInfo {
  deviceId: string
  name?: string
  type: DeviceType
  platform?: string
  browser?: string
  ipAddress?: string
  location?: string
}

export class AuthAuditService {
  /**
   * Log a login attempt (success or failure)
   * This is what enterprise sites use for compliance and security
   */
  static async logLoginAttempt(attempt: LoginAttempt) {
    const deviceId = attempt.deviceFingerprint
    let userDevice = null
    
    // If we have a device fingerprint, find or create the device
    if (deviceId && attempt.userId) {
      userDevice = await prisma.userDevice.upsert({
        where: { deviceId },
        update: {
          lastSeenAt: new Date(),
          ipAddress: attempt.ipAddress,
          location: attempt.location,
        },
        create: {
          userId: attempt.userId,
          deviceId,
          type: DeviceType.UNKNOWN, // Will be updated by device detection
          ipAddress: attempt.ipAddress,
          location: attempt.location,
        },
      })
    }
    
    // Calculate risk score based on various factors
    const riskScore = this.calculateRiskScore(attempt, userDevice)
    
    // Log the login attempt
    const loginAudit = await prisma.loginAudit.create({
      data: {
        userId: attempt.userId,
        email: attempt.email,
        result: attempt.result,
        ipAddress: attempt.ipAddress,
        userAgent: attempt.userAgent,
        deviceId: userDevice?.id,
        location: attempt.location,
        failureReason: attempt.failureReason,
        riskScore,
        isSuspicious: riskScore > 70, // Flag high-risk logins
      },
    })
    
    // If it's a successful login, create security event
    if (attempt.result === LoginResult.SUCCESS) {
      await this.logSecurityEvent({
        userId: attempt.userId!,
        eventType: SecurityEventType.LOGIN_SUCCESS,
        description: `Successful login from ${attempt.ipAddress}`,
        ipAddress: attempt.ipAddress,
        userAgent: attempt.userAgent,
        deviceId: userDevice?.id,
        riskScore,
      })
    }
    
    return loginAudit
  }
  
  /**
   * Calculate risk score for login attempts
   * Enterprise sites use this for adaptive authentication
   */
  private static calculateRiskScore(attempt: LoginAttempt, device?: any): number {
    let score = 0
    
    // New device = higher risk
    if (!device) score += 30
    
    // Failed login = higher risk
    if (attempt.result !== LoginResult.SUCCESS) score += 20
    
    // Geographic anomaly (simplified - in production, use IP geolocation)
    if (attempt.location && device?.location && attempt.location !== device.location) {
      score += 25
    }
    
    // Time-based anomaly (login at unusual hours)
    const hour = new Date().getHours()
    if (hour < 6 || hour > 22) score += 15
    
    // Multiple failed attempts from same IP (check recent history)
    // This would require additional query in production
    
    return Math.min(score, 100)
  }
  
  /**
   * Log security events for audit trail
   */
  static async logSecurityEvent(event: {
    userId?: string
    eventType: SecurityEventType
    description?: string
    ipAddress?: string
    userAgent?: string
    deviceId?: string
    sessionId?: string
    riskScore?: number
    metadata?: any
  }) {
    return await prisma.securityEvent.create({
      data: {
        userId: event.userId,
        eventType: event.eventType,
        description: event.description,
        ipAddress: event.ipAddress,
        userAgent: event.userAgent,
        deviceId: event.deviceId,
        sessionId: event.sessionId,
        riskScore: event.riskScore || 0,
        metadata: event.metadata,
      },
    })
  }
  
  /**
   * Register or update a user device
   */
  static async registerDevice(userId: string, deviceInfo: DeviceInfo) {
    return await prisma.userDevice.upsert({
      where: { deviceId: deviceInfo.deviceId },
      update: {
        lastSeenAt: new Date(),
        ipAddress: deviceInfo.ipAddress,
        location: deviceInfo.location,
        platform: deviceInfo.platform,
        browser: deviceInfo.browser,
      },
      create: {
        userId,
        deviceId: deviceInfo.deviceId,
        name: deviceInfo.name,
        type: deviceInfo.type,
        platform: deviceInfo.platform,
        browser: deviceInfo.browser,
        ipAddress: deviceInfo.ipAddress,
        location: deviceInfo.location,
      },
    })
  }
  
  /**
   * Get user's trusted devices
   */
  static async getUserDevices(userId: string) {
    return await prisma.userDevice.findMany({
      where: { 
        userId,
        isActive: true,
      },
      orderBy: { lastSeenAt: 'desc' },
    })
  }
  
  /**
   * Trust a device (reduces future login friction)
   */
  static async trustDevice(deviceId: string) {
    return await prisma.userDevice.update({
      where: { deviceId },
      data: {
        isTrusted: true,
        trustedAt: new Date(),
        trustLevel: 100,
      },
    })
  }
  
  /**
   * Revoke device access
   */
  static async revokeDevice(deviceId: string) {
    return await prisma.userDevice.update({
      where: { deviceId },
      data: {
        isActive: false,
        isTrusted: false,
        revokedAt: new Date(),
      },
    })
  }
  
  /**
   * Get recent login attempts for security dashboard
   */
  static async getRecentLoginAttempts(userId: string, limit = 50) {
    return await prisma.loginAudit.findMany({
      where: { userId },
      orderBy: { timestamp: 'desc' },
      take: limit,
      include: {
        device: true,
      },
    })
  }
  
  /**
   * Get security events for user
   */
  static async getSecurityEvents(userId: string, limit = 50) {
    return await prisma.securityEvent.findMany({
      where: { userId },
      orderBy: { occurredAt: 'desc' },
      take: limit,
      include: {
        device: true,
      },
    })
  }
  
  /**
   * Extract device info from request headers
   */
  static extractDeviceInfo(req: any): DeviceInfo {
    const userAgent = req.headers.get?.('user-agent') || req.headers['user-agent'] || ''
    const ip = this.extractIpAddress(req)
    
    // Simple device fingerprinting (in production, use more sophisticated methods)
    const deviceId = this.generateDeviceFingerprint(userAgent, ip)
    
    return {
      deviceId,
      type: this.detectDeviceType(userAgent),
      platform: this.detectPlatform(userAgent),
      browser: this.detectBrowser(userAgent),
      ipAddress: ip,
      // Location would be determined by IP geolocation service
    }
  }
  
  /**
   * Extract IP address from request
   */
  private static extractIpAddress(req: any): string | undefined {
    return (
      req.headers.get?.('x-forwarded-for') ||
      req.headers.get?.('x-real-ip') ||
      req.headers['x-forwarded-for'] ||
      req.headers['x-real-ip'] ||
      req.connection?.remoteAddress ||
      req.socket?.remoteAddress ||
      req.info?.remoteAddress
    )
  }
  
  /**
   * Generate device fingerprint
   */
  private static generateDeviceFingerprint(userAgent: string, ip?: string): string {
    const data = `${userAgent}:${ip || 'unknown'}`
    // In production, use crypto.createHash('sha256').update(data).digest('hex')
    return Buffer.from(data).toString('base64').slice(0, 32)
  }
  
  /**
   * Simple device type detection
   */
  private static detectDeviceType(userAgent: string): DeviceType {
    const ua = userAgent.toLowerCase()
    if (ua.includes('mobile') || ua.includes('android') || ua.includes('iphone')) {
      return DeviceType.MOBILE
    }
    if (ua.includes('tablet') || ua.includes('ipad')) {
      return DeviceType.TABLET
    }
    return DeviceType.DESKTOP
  }
  
  /**
   * Simple platform detection
   */
  private static detectPlatform(userAgent: string): string {
    const ua = userAgent.toLowerCase()
    if (ua.includes('windows')) return 'Windows'
    if (ua.includes('mac')) return 'macOS'
    if (ua.includes('linux')) return 'Linux'
    if (ua.includes('android')) return 'Android'
    if (ua.includes('ios') || ua.includes('iphone') || ua.includes('ipad')) return 'iOS'
    return 'Unknown'
  }
  
  /**
   * Simple browser detection
   */
  private static detectBrowser(userAgent: string): string {
    const ua = userAgent.toLowerCase()
    if (ua.includes('chrome')) return 'Chrome'
    if (ua.includes('firefox')) return 'Firefox'
    if (ua.includes('safari')) return 'Safari'
    if (ua.includes('edge')) return 'Edge'
    return 'Unknown'
  }
} 