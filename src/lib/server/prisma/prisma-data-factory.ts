/**
 * Prisma Data Factory - Clean, Schema-Driven Data Preparation
 * 
 * This factory eliminates complex runtime conversions by using
 * schema-driven data preparation that guarantees Prisma compatibility.
 * 
 * KEY PRINCIPLES:
 * 1. Schema defines EXACTLY what Prisma expects
 * 2. Zero runtime conversion logic
 * 3. Factory pattern for consistent data preparation
 * 4. Bulletproof defaults handling
 * 
 * HOW TO ADD NEW MODELS:
 * 1. Add model to PRISMA_FIELD_CONFIG with:
 *    - nullableWithDefaults: Fields to omit when null (have Prisma @default)
 *    - relationships: Foreign key → Relationship name mapping
 *    - required: Fields that must have values
 *    - autoGenerated: Fields to skip in validation
 * 
 * 2. Example:
 *    MyModel: {
 *      nullableWithDefaults: ['optionalArray'],
 *      relationships: {
 *        tenantId: 'tenant',
 *        createdById: 'createdBy'
 *      },
 *      required: ['id', 'name'],
 *      autoGenerated: ['id', 'createdAt', 'updatedAt']
 *    }
 * 
 * 3. The factory handles the rest automatically!
 */

import type { ResourceSchema } from '@/lib/resource-system/schemas';
import { generateNodeShortId, generateRuleShortId, generateClassShortId } from '@/lib/utils/short-id-generator';

// ============================================================================
// PRISMA FIELD MAPPINGS - SINGLE SOURCE OF TRUTH
// ============================================================================

/**
 * Prisma field configuration for each model
 * This eliminates guesswork and runtime detection
 */
const PRISMA_FIELD_CONFIG = {
  Node: {
    // Fields that should be omitted when null (have Prisma defaults)
    nullableWithDefaults: ['path', 'level', 'sortOrder', 'childCount', 'isLeaf', 'ancestorIds'],
    
    // Foreign key -> Relationship mappings
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch', 
      originalNodeId: 'originalNode',
      createdById: 'createdBy',
      updatedById: 'updatedBy',
      // Convert parentId to nested parent connect to satisfy Prisma CreateInput
      parentId: 'parent'
    },
    
    // Required fields that must have values
    required: ['id', 'name', 'type'],
    
    // Auto-generated fields
    autoGenerated: ['id', 'idShort', 'createdAt', 'updatedAt', 'version']
  },
  
  Rule: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      originalRuleId: 'originalRule', 
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name', 'type'],
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  },
  
  Process: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      originalProcessId: 'originalProcess',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name', 'type'],
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  },
  
  Office: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      originalOfficeId: 'originalOffice',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  },
  
  Workflow: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      originalWorkflowId: 'originalWorkflow',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  },
  
  // Branch (non-branching resource)
  Branch: {
    // Fields with Prisma defaults that can be omitted when null/undefined
    nullableWithDefaults: ['description', 'lockedById', 'lockedAt'],
    
    // Foreign key -> Relationship mappings (no branch relation on Branch)
    relationships: {
      tenantId: 'tenant',
      createdById: 'createdBy',
      updatedById: 'updatedBy',
      lockedById: 'lockedByUser'
    },
    
    // Minimal required fields for create (id auto-generates via nanoid())
    required: ['name'],
    
    // Auto-generated by Prisma/database
    autoGenerated: ['id', 'createdAt', 'updatedAt'],
    
    // Remove fields not present on Branch model if accidentally added
    computedFields: ['version']
  },
  
  // Junction Tables (simplified - no branching relationships)
  NodeProcess: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // nodeId, processId stay as foreign keys
    },
    // Junction uses composite key (nodeId + processId + branchId); no single 'id'
    required: ['tenantId', 'branchId', 'nodeId', 'processId'],
    autoGenerated: ['createdAt', 'updatedAt']
  },
  
  ProcessRule: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // processId, ruleId stay as foreign keys
    },
    required: ['tenantId', 'branchId', 'processId', 'ruleId'],
    autoGenerated: ['createdAt', 'updatedAt']
  },
  
  NodeWorkflow: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // nodeId, workflowId stay as foreign keys
    },
    required: ['tenantId', 'branchId', 'nodeId', 'workflowId'],
    autoGenerated: ['createdAt', 'updatedAt']
  },
  
  WorkflowProcess: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // workflowId, processId stay as foreign keys
    },
    required: ['tenantId', 'branchId', 'workflowId', 'processId'],
    autoGenerated: ['createdAt', 'updatedAt']
  },
  
  RuleIgnore: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // ruleId, nodeId stay as foreign keys
    },
    required: ['tenantId', 'branchId', 'ruleId', 'nodeId'],
    autoGenerated: ['createdAt', 'updatedAt']
  },
  
  // Additional Entity Models
  Tag: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // tagGroupId stays as foreign key
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  TagGroup: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  Customer: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  Class: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  // Tag Junction Tables
  RuleTag: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // ruleId, tagId stay as foreign keys
    },
    required: ['id', 'ruleId', 'tagId'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  NodeTag: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // nodeId, tagId stay as foreign keys
    },
    required: ['id', 'nodeId', 'tagId'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  ProcessTag: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // processId, tagId stay as foreign keys
    },
    required: ['id', 'processId', 'tagId'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  WorkflowTag: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // workflowId, tagId stay as foreign keys
    },
    required: ['id', 'workflowId', 'tagId'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  OfficeTag: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // officeId, tagId stay as foreign keys
    },
    required: ['id', 'officeId', 'tagId'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  ClassTag: {
    nullableWithDefaults: [],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
      // classId, tagId stay as foreign keys
    },
    required: ['id', 'classId', 'tagId'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  },
  
  TableCategory: {
    nullableWithDefaults: ['description'],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      originalTableCategoryId: 'originalTableCategory',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  },
  
  Table: {
    nullableWithDefaults: ['description', 'tableName', 'config', 'categoryId'],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      categoryId: 'category',
      originalTableId: 'originalTable',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  },
  
  TableData: {
    nullableWithDefaults: ['originalTableDataId', 'createdById', 'updatedById'],
    relationships: {
      tableId: 'table',
      tenantId: 'tenant',
      branchId: 'branch',
      originalTableDataId: 'originalTableData',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    // ✅ FIXED: tableId gets converted to relationship, so only data is required after conversion
    required: ['data'],
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  },
  
  Prompt: {
    // Fields that should be omitted when null (have Prisma defaults)
    nullableWithDefaults: ['ruleName', 'layout', 'isPublic', 'executionMode', 'isActive', 'version'],
    
    // Foreign key -> Relationship mappings
    relationships: {
      ruleId: 'rule',
      tenantId: 'tenant',
      branchId: 'branch',
      originalPromptId: 'originalPrompt',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    
    // Required fields that must have values (ruleId converted to relationship, content can be empty, id is auto-generated)
    required: ['promptName'],
    
    // Auto-generated fields
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  },
  
  MarketplacePackage: {
    // Fields that should be omitted when null (have Prisma defaults)
    nullableWithDefaults: ['tags', 'selectedRules', 'selectedClasses', 'selectedTables', 'selectedWorkflows', 'allowedTenants', 'downloadCount', 'installCount', 'activeInstalls', 'reviewCount', 'totalRevenue', 'monthlyRevenue', 'price', 'subscriptionInterval', 'usageUnit', 'usagePrice', 'publishingNotes', 'rating'],
    
    // Foreign key -> Relationship mappings (NO branchId - marketplace packages are global)
    relationships: {
      tenantId: 'tenant',
      authorId: 'author',
      originalPackageId: 'originalPackage',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    
    // Required fields that must have values
    required: ['id', 'name', 'description', 'version', 'category', 'licenseType'],
    
    // Auto-generated fields
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version_number'],
    
    // ✅ MARKETPLACE PACKAGES: Exclude branchId completely (global resources)
    excludeFields: ['branchId']
  }
} as const;

type PrismaModelName = keyof typeof PRISMA_FIELD_CONFIG;

// ============================================================================
// PRISMA DATA FACTORY
// ============================================================================

export class PrismaDataFactory {
  
  /**
   * Prepare data for Prisma create/update operations
   * This is the ONLY function that should prepare data for Prisma
   */
  static prepareForPrisma(
    data: any,
    schema: ResourceSchema,
    context: any, // Accept any context and normalize internally
    operation: 'create' | 'update' = 'create'
  ): any {
    const modelName = schema.modelName as PrismaModelName;
    const config = PRISMA_FIELD_CONFIG[modelName];
    
    if (!config) {
      throw new Error(`No Prisma configuration found for model: ${modelName}`);
    }
    
    const result = { ...data };

    // Step 1: Add audit fields
    this.addAuditFields(result, context, operation, schema);

    // Step 1.5: If Zod schema is provided on ResourceSchema, validate now (schema-driven)
    const zodSchema: any = (schema as any)?.schema;
    if (zodSchema && typeof zodSchema.safeParse === 'function') {
      const parsed = zodSchema.safeParse(result);
      if (!parsed.success) {
        const first = parsed.error.issues?.[0];
        const msg = first ? `${first.path?.join('.') || 'root'}: ${first.message}` : parsed.error.message;
        throw new Error(`Schema validation failed for ${modelName}: ${msg}`);
      }
      // Use parsed result to ensure proper defaults/coercions
      Object.assign(result, parsed.data);
    }

    // Step 1.6: Generate short IDs for key models if missing
    if (operation === 'create') {
      if (modelName === 'Node' && !result.idShort) {
        result.idShort = generateNodeShortId();
      } else if (modelName === 'Rule' && !result.idShort) {
        result.idShort = generateRuleShortId();
      } else if (modelName === 'Class' && !result.idShort) {
        result.idShort = generateClassShortId();
      }
    }

    // Step 2: Convert foreign keys to relationships (schema-driven + config)
    this.convertToRelationships(result, config, schema);
    
    // Step 3: Remove null fields with defaults
    this.removeNullDefaults(result, config);
    
    // Step 4: Remove computed fields (let Prisma/DB handle them)
    this.removeComputedFields(result, config);
    
    // Step 4.5: Remove excluded fields (for server-only resources like marketplace packages)
    this.removeExcludedFields(result, config);
    
    // Step 5: Validate required fields (skip if Zod schema handled validation)
    if (!(zodSchema && typeof zodSchema.safeParse === 'function')) {
      this.validateRequired(result, config, modelName);
    }
    
    return result;
  }
  
  /**
   * Add audit fields (createdAt, updatedAt, etc.)
   */
  private static addAuditFields(
    data: any, 
    context: any, 
    operation: 'create' | 'update',
    schema?: ResourceSchema
  ): void {
    const now = new Date();
    
    if (operation === 'create') {
      data.createdAt = data.createdAt || now;
      data.createdById = data.createdById || context.userId;
      // Only set version when the model actually has a version column
      try {
        const modelName = (schema as any)?.modelName as keyof typeof PRISMA_FIELD_CONFIG;
        const cfg = modelName ? (PRISMA_FIELD_CONFIG as any)[modelName] : null;
        const hasVersion = !!cfg && Array.isArray(cfg.autoGenerated) && cfg.autoGenerated.includes('version');
        if (hasVersion) {
          data.version = data.version || 1;
        }
      } catch {}

      // Generate short IDs for primary entities
      if (!data.idShort) {
        // We don't have schema here; infer by presence of other fields
        // Prefer explicit flags set by caller via schema.modelName if needed
      }
    }
    
    data.updatedAt = now;
    data.updatedById = context.userId;
    
    // Add tenant/branch context - only add branchId when schema supports branching
    data.tenantId = data.tenantId || context.tenantId;
    const schemaConfig: any = schema || {};
    const hasBranchContext = !(schemaConfig && schemaConfig.notHasBranchContext === true);
    if (hasBranchContext) {
      data.branchId = data.branchId || context.branchId || context.currentBranchId;
    }
  }
  
  /**
   * Convert foreign keys to Prisma relationships
   */
  private static convertToRelationships(
    data: any,
    config: any,
    schema?: ResourceSchema
  ): void {
    // Base mappings from hard-coded Prisma config
    const baseMappings: Record<string, string> = config.relationships || {};

    // Merge in mappings derived from ResourceSchema.relationships (schema-driven)
    const schemaMappings: Record<string, string> = {};
    try {
      const rels: any = (schema as any)?.relationships || {};
      for (const [relationName, relConfig] of Object.entries(rels)) {
        if (
          relConfig &&
          (relConfig as any).type === 'one-to-one' &&
          typeof (relConfig as any).foreignKey === 'string' &&
          (relConfig as any).foreignKey.length > 0
        ) {
          schemaMappings[(relConfig as any).foreignKey] = relationName;
        }
      }
    } catch {}

    const relationships: Record<string, string> = { ...schemaMappings, ...baseMappings };

    for (const [foreignKey, relationName] of Object.entries(relationships)) {
      if (foreignKey in data) {
        const value = (data as any)[foreignKey];
        if (value && typeof value === 'string') {
          // Convert to relationship connect
          (data as any)[relationName] = { connect: { id: value } };
        }
        // Always remove the foreign key field
        delete (data as any)[foreignKey];
      }
    }
  }
  
  /**
   * Remove null fields that have Prisma defaults
   */
  private static removeNullDefaults(data: any, config: any): void {
    const nullableFields = config.nullableWithDefaults || [];
    
    for (const field of nullableFields) {
      if (data[field] === null || data[field] === undefined) {
        delete data[field];
      }
    }
  }
  
  /**
   * Remove computed fields that should be handled by Prisma/database
   */
  private static removeComputedFields(data: any, config: any): void {
    const computedFields = config.computedFields || [];
    
    for (const field of computedFields) {
      if (data[field] !== null && data[field] !== undefined) {
        delete data[field];
      }
    }
  }
  
  /**
   * Remove excluded fields (for server-only resources like marketplace packages)
   */
  private static removeExcludedFields(data: any, config: any): void {
    const excludedFields = config.excludeFields || [];
    
    for (const field of excludedFields) {
      if (data[field] !== null && data[field] !== undefined) {
        delete data[field];
      }
    }
  }
  
  /**
   * Validate required fields are present
   */
  private static validateRequired(data: any, config: any, modelName: string): void {
    const required = config.required || [];
    const missing = required.filter(field => !data[field]);
    
    if (missing.length > 0) {
      throw new Error(`Missing required fields for ${modelName}: ${missing.join(', ')}`);
    }
  }
}

// ============================================================================
// SCHEMA INTEGRATION HELPERS
// ============================================================================

/**
 * Helper to get Prisma-ready default values from schema
 */
export function getPrismaDefaults(schema: ResourceSchema): Record<string, any> {
  const modelName = schema.modelName as PrismaModelName;
  const config = PRISMA_FIELD_CONFIG[modelName];
  
  if (!config) return {};
  
  const defaults: Record<string, any> = {};
  
  // Set defaults for nullable fields
  for (const field of config.nullableWithDefaults) {
    if (field === 'path' || field === 'ancestorIds') {
      defaults[field] = [];
    }
  }
  
  return defaults;
}

/**
 * Helper to check if a field should be auto-generated
 */
export function isAutoGeneratedField(fieldKey: string, schema: ResourceSchema): boolean {
  const modelName = schema.modelName as PrismaModelName;
  const config = PRISMA_FIELD_CONFIG[modelName];
  
  return config?.autoGenerated.includes(fieldKey) || false;
}