# Creating New Resources - Complete Guide

## Table of Contents
1. [Quick Start](#quick-start)
2. [Step-by-Step Walkthrough](#step-by-step-walkthrough)
3. [Schema Design](#schema-design)
4. [Database Integration](#database-integration)
5. [Testing Your Resource](#testing-your-resource)
6. [Advanced Features](#advanced-features)
7. [Common Patterns](#common-patterns)
8. [Troubleshooting](#troubleshooting)

---

## Quick Start

Adding a new resource is **incredibly simple** - define one schema and the system generates everything else:

```typescript
// 1. Create schema file: src/features/customers/customers.schema.ts
export const CUSTOMER_SCHEMA: ResourceSchema = {
  databaseKey: 'customers',
  modelName: 'Customer',
  actionPrefix: 'customer',
  
  display: {
    title: 'Customers',
    icon: 'users',
    color: 'green'
  },
  
  fields: [
    {
      key: 'name',
      label: 'Customer Name',
      type: 'text',
      required: true,
      mobile: { priority: 'high', displayFormat: 'text' },
      desktop: { showInTable: true, tableWidth: 'lg', sortable: true }
    }
    // ... more fields
  ],
  
  actions: {
    create: true,
    update: true,
    delete: true
  }
};

// 2. Register in resource registry
// src/lib/resource-system/resource-registry.ts
import { CUSTOMER_SCHEMA } from '@/features/customers/customers.schema';

const SCHEMA_RESOURCES = [
  // ... existing schemas
  CUSTOMER_SCHEMA  // Add this line
];

// 3. Configure Prisma (CRITICAL!)
// src/lib/server/prisma/prisma-data-factory.ts
const PRISMA_FIELD_CONFIG = {
  Customer: {
    nullableWithDefaults: ['description'],
    relationships: { tenantId: 'tenant', branchId: 'branch' },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt']
  }
};

// 4. Use everywhere
const { data: customers } = useActionQuery('customer.list');
<AutoTable resourceKey="customers" />
```

**That's it!** The system automatically generates:
- ‚úÖ API endpoints and handlers
- ‚úÖ IndexedDB stores and indexes
- ‚úÖ TypeScript types and validation
- ‚úÖ React hooks and queries
- ‚úÖ UI components (tables, forms, modals)
- ‚úÖ CRUD operations with optimistic updates

---

## Step-by-Step Walkthrough

Let's create a complete **Customer** resource from scratch.

### **Step 1: Create Schema File**

Create `src/features/customers/customers.schema.ts`:

```typescript
import type { ResourceSchema } from '@/lib/resource-system/schemas';

export const CUSTOMER_SCHEMA: ResourceSchema = {
  // ============================================================================
  // CORE IDENTITY - These 3 fields must be consistent
  // ============================================================================
  databaseKey: 'customers',     // IndexedDB store + API endpoint (plural)
  modelName: 'Customer',        // Prisma model name (singular, PascalCase)
  actionPrefix: 'customer',     // Action namespace (customer.create, etc.)
  
  // ============================================================================
  // UI DISPLAY
  // ============================================================================
  display: {
    title: 'Customers',
    singularTitle: 'Customer',
    description: 'Customer management and relationships',
    icon: 'users',              // Lucide React icon name
    color: 'green',             // Theme color
    pluralRules: {
      singular: 'customer',
      plural: 'customers'
    }
  },
  
  // ============================================================================
  // FIELD DEFINITIONS - Mobile-first design
  // ============================================================================
  fields: [
    // Auto-generated ID
    {
      key: 'id',
      label: 'ID',
      type: 'text',
      required: true,
      autoValue: { source: 'auto.uuid' },
      mobile: { priority: 'low', displayFormat: 'hidden' },
      desktop: { showInTable: false, tableWidth: 'sm' }
    },
    
    // Primary name field
    {
      key: 'name',
      label: 'Customer Name',
      type: 'text',
      required: true,
      placeholder: 'Enter customer name',
      validation: [
        { type: 'required', message: 'Customer name is required' },
        { type: 'minLength', value: 2, message: 'Name must be at least 2 characters' },
        { type: 'maxLength', value: 100, message: 'Name cannot exceed 100 characters' }
      ],
      mobile: { priority: 'high', displayFormat: 'text' },
      desktop: { showInTable: true, tableWidth: 'lg', sortable: true, filterable: true }
    },
    
    // Email field with validation
    {
      key: 'email',
      label: 'Email Address',
      type: 'email',
      placeholder: 'customer@company.com',
      validation: [
        { type: 'email', message: 'Please enter a valid email address' }
      ],
      mobile: { priority: 'high', displayFormat: 'text' },
      desktop: { showInTable: true, tableWidth: 'md', sortable: true }
    },
    
    // Phone number
    {
      key: 'phone',
      label: 'Phone Number',
      type: 'tel',
      placeholder: '+1 (555) 123-4567',
      mobile: { priority: 'medium', displayFormat: 'text' },
      desktop: { showInTable: true, tableWidth: 'md' }
    },
    
    // Company name
    {
      key: 'company',
      label: 'Company',
      type: 'text',
      placeholder: 'Company name',
      mobile: { priority: 'medium', displayFormat: 'text' },
      desktop: { showInTable: true, tableWidth: 'md', sortable: true }
    },
    
    // Address
    {
      key: 'address',
      label: 'Address',
      type: 'textarea',
      placeholder: 'Enter full address',
      mobile: { priority: 'medium', displayFormat: 'text', condensed: true },
      desktop: { showInTable: false, tableWidth: 'xl' }
    },
    
    // Customer type with select options
    {
      key: 'type',
      label: 'Customer Type',
      type: 'select',
      required: true,
      defaultValue: 'individual',
      options: {
        static: [
          { value: 'individual', label: 'Individual' },
          { value: 'business', label: 'Business' },
          { value: 'enterprise', label: 'Enterprise' }
        ]
      },
      mobile: { priority: 'high', displayFormat: 'badge' },
      desktop: { showInTable: true, tableWidth: 'sm', filterable: true }
    },
    
    // Status
    {
      key: 'status',
      label: 'Status',
      type: 'select',
      required: true,
      defaultValue: 'active',
      options: {
        static: [
          { value: 'active', label: 'Active' },
          { value: 'inactive', label: 'Inactive' },
          { value: 'prospect', label: 'Prospect' },
          { value: 'churned', label: 'Churned' }
        ]
      },
      mobile: { priority: 'high', displayFormat: 'badge' },
      desktop: { showInTable: true, tableWidth: 'sm', filterable: true }
    },
    
    // Notes (internal)
    {
      key: 'notes',
      label: 'Internal Notes',
      type: 'textarea',
      placeholder: 'Internal notes about this customer...',
      mobile: { priority: 'low', displayFormat: 'hidden' },
      desktop: { showInTable: false, tableWidth: 'xl' }
    },
    
    // Metadata JSON
    {
      key: 'metadata',
      label: 'Metadata',
      type: 'json',
      helpText: 'Additional customer data in JSON format',
      mobile: { priority: 'low', displayFormat: 'hidden' },
      desktop: { showInTable: false, tableWidth: 'xl' }
    },
    
    // Active flag
    {
      key: 'isActive',
      label: 'Active',
      type: 'switch',
      defaultValue: true,
      mobile: { priority: 'medium', displayFormat: 'pill' },
      desktop: { showInTable: true, tableWidth: 'xs', filterable: true }
    }
  ],
  
  // ============================================================================
  // RELATIONSHIPS
  // ============================================================================
  relationships: {
    // Many customers can belong to one office
    office: {
      type: 'many-to-one',
      relatedEntity: 'offices',
      foreignKey: 'officeId',
      displayInForm: true,
      displayInTable: true,
      displayInDetail: true
    },
    
    // Customer can have many orders (if you have orders)
    // orders: {
    //   type: 'one-to-many',
    //   relatedEntity: 'orders',
    //   foreignKey: 'customerId',
    //   displayInDetail: true,
    //   cascadeDelete: false
    // }
  },
  
  // ============================================================================
  // ACTIONS CONFIGURATION
  // ============================================================================
  actions: {
    // Standard CRUD operations
    create: true,
    update: true,
    delete: true,
    list: true,
    get: true,
    
    // Bulk operations
    bulkCreate: true,
    bulkUpdate: true,
    bulkDelete: true,
    
    // Custom actions
    custom: [
      {
        id: 'sendEmail',
        label: 'Send Email',
        description: 'Send email to customer',
        icon: 'mail',
        handler: 'sendCustomerEmail',
        optimistic: false  // Server validation required
      },
      {
        id: 'duplicate',
        label: 'Duplicate Customer',
        handler: 'duplicateCustomer',
        optimistic: true
      }
    ]
  }
};
```

### **Step 2: Register Schema**

Add to `src/lib/resource-system/resource-registry.ts`:

```typescript
// Import your new schema
import { CUSTOMER_SCHEMA } from '@/features/customers/customers.schema';

// Add to the schema resources array
const SCHEMA_RESOURCES: ResourceSchema[] = [
  NODE_SCHEMA,
  PROCESS_SCHEMA,
  RULE_SCHEMA,
  OFFICE_SCHEMA,
  WORKFLOW_SCHEMA,
  PROMPT_SCHEMA,
  CUSTOMER_SCHEMA  // ‚Üê Add this line
];
```

**That's it for the frontend!** The system now auto-generates:
- ‚úÖ API endpoints: `/api/workspaces/current/actions` with customer actions
- ‚úÖ IndexedDB store: `customers` with branch-aware compound keys
- ‚úÖ TypeScript types: `Customer`, `CreateCustomer`, `UpdateCustomer`
- ‚úÖ React hooks: `useActionQuery('customer.list')`, `useActionAPI('customer')`
- ‚úÖ UI components: `<AutoTable resourceKey="customers" />`

### **Step 3: Configure Prisma Integration** üö® **CRITICAL STEP**

**This step is essential - without it you'll get "No Prisma configuration found for model: Customer" errors!**

Add your model to the `PRISMA_FIELD_CONFIG` in `src/lib/server/prisma/prisma-data-factory.ts`:

```typescript
// src/lib/server/prisma/prisma-data-factory.ts
const PRISMA_FIELD_CONFIG = {
  // ... existing models (Node, Rule, Process, etc.)
  
  Customer: {
    // Fields that should be omitted when null (have Prisma @default values)
    nullableWithDefaults: ['description', 'avatar', 'metadata', 'notes'],
    
    // Foreign key ‚Üí Relationship name mappings for Prisma
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      officeId: 'office',                    // If Customer belongs to Office
      originalCustomerId: 'originalCustomer', // For branching support
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    
    // Required fields that must have values
    required: ['id', 'name'],
    
    // Auto-generated fields (excluded from validation)
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  }
} as const;
```

**Configuration Guidelines:**

- **`nullableWithDefaults`**: Fields that have `@default()` in Prisma schema - omit when null to let Prisma handle defaults
- **`relationships`**: Maps foreign key fields to Prisma relationship names (enables nested creates/connects)  
- **`required`**: Fields that must be present (validates before Prisma operations)
- **`autoGenerated`**: Fields handled by Prisma/database (excluded from validation)

### **Step 4: Database Schema (Prisma)**

Add to `prisma/schema.prisma`:

```prisma
model Customer {
  // ============================================================================
  // PRIMARY FIELDS
  // ============================================================================
  id          String   @id @default(cuid())
  name        String
  email       String?  @unique
  phone       String?
  company     String?
  address     String?
  type        String   @default("individual") // individual, business, enterprise
  status      String   @default("active")     // active, inactive, prospect, churned
  notes       String?
  metadata    Json?
  isActive    Boolean  @default(true)
  
  // ============================================================================
  // SYSTEM FIELDS (Required for action system)
  // ============================================================================
  tenantId    String   // Multi-tenant support
  branchId    String   // Branch-aware versioning
  
  // ============================================================================
  // RELATIONSHIPS
  // ============================================================================
  officeId    String?
  office      Office?  @relation(fields: [officeId], references: [id])
  
  // Add other relationships here
  // orders      Order[]  @relation("CustomerOrders")
  
  // ============================================================================
  // BRANCHING SYSTEM (Required)
  // ============================================================================
  originalCustomerId String?
  originalCustomer   Customer? @relation("BranchVersionCustomer", fields: [originalCustomerId], references: [id])
  branchedCustomers  Customer[] @relation("BranchVersionCustomer")
  
  // ============================================================================
  // AUDIT FIELDS (Optional but recommended)
  // ============================================================================
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String?
  updatedById String?
  
  // ============================================================================
  // INDEXES (Critical for performance)
  // ============================================================================
  @@index([branchId])
  @@index([tenantId, branchId])
  @@index([status])
  @@index([type])
  @@index([officeId])
  @@map("customers")
}
```

Run database migration:

```bash
npx prisma db push
# or
npx prisma migrate dev --name add-customers
```

### **Step 4: Test Your Resource**

Your resource is now fully functional! Test it:

```typescript
// In any React component
import { useActionQuery, useActionAPI } from '@/hooks/use-action-api';
import { AutoTable, AutoModal } from '@/components/auto-generated';
import { CUSTOMER_SCHEMA } from '@/features/customers/customers.schema';

const CustomerPage = () => {
  // Data fetching (cache-first, <50ms)
  const { data: customers, isLoading } = useActionQuery('customer.list');
  
  // Mutations (optimistic updates)
  const { createCustomer, updateCustomer, deleteCustomer } = useActionAPI('customer');
  
  // Modal state
  const [modalState, setModalState] = useState({
    isOpen: false,
    action: 'create',
    data: null
  });

  const handleCreate = async (data) => {
    await createCustomer(data);
    console.log('Customer created instantly!');
  };

  return (
    <div className="customer-page">
      <h1>Customer Management</h1>
      
      {/* Complete CRUD table */}
      <AutoTable 
        resourceKey="customers"
        filters={{ status: 'active' }}
        onRowClick={(customer) => console.log('Selected:', customer)}
      />
      
      {/* CRUD modal */}
      <AutoModal
        isOpen={modalState.isOpen}
        onClose={() => setModalState({ isOpen: false })}
        config={{
          resource: 'customer',
          action: modalState.action,
          width: 'lg'
        }}
        schema={CUSTOMER_SCHEMA}
        initialData={modalState.data}
        onSuccess={() => {
          console.log('Operation completed!');
          setModalState({ isOpen: false });
        }}
      />
    </div>
  );
};
```

**Test the complete functionality:**

```typescript
// All of these work immediately:

// 1. Load customers (cache-first)
const { data: customers } = useActionQuery('customer.list');

// 2. Create customer (optimistic)
await createCustomer({ name: 'John Doe', email: 'john@example.com' });

// 3. Update customer (Copy-on-Write if needed)
await updateCustomer('cust123', { name: 'Jane Doe' });

// 4. Delete customer (optimistic)
await deleteCustomer('cust123');

// 5. Custom actions
await customAction('customer.sendEmail', { id: 'cust123', message: 'Hello!' });

// 6. Bulk operations
await createBatch('customer', [customer1, customer2, customer3]);

// 7. Junction relationships (if configured)
const { data: customers, junctions } = useActionQuery('customer.list', {}, {
  includeJunctions: ['customer_orders']
});
```

---

## Schema Design

### **Field Design Best Practices**

**1. Essential Field Configuration:**
```typescript
{
  key: 'fieldName',          // Database field name
  label: 'Display Label',    // UI label
  type: 'text',             // Field type
  required: true,           // Validation
  
  // Mobile-first (required)
  mobile: {
    priority: 'high',       // high | medium | low
    displayFormat: 'text'   // text | badge | pill | hidden
  },
  
  // Desktop configuration (required)
  desktop: {
    showInTable: true,      // Show in tables
    tableWidth: 'lg',       // xs | sm | md | lg | xl
    sortable: true,         // Enable sorting
    filterable: false       // Enable filtering
  }
}
```

**2. Validation Patterns:**
```typescript
// Required field
validation: [
  { type: 'required', message: 'This field is required' }
]

// Email validation
validation: [
  { type: 'email', message: 'Please enter a valid email address' }
]

// Length validation
validation: [
  { type: 'minLength', value: 2, message: 'Too short' },
  { type: 'maxLength', value: 100, message: 'Too long' }
]

// Pattern validation
validation: [
  {
    type: 'pattern',
    value: /^[A-Za-z0-9]+$/,
    message: 'Only letters and numbers allowed'
  }
]

// Custom validation
validation: [
  {
    type: 'custom',
    message: 'Custom validation failed',
    validator: (value, formData) => {
      return value.length > 5 && formData.otherField !== 'invalid';
    }
  }
]
```

**3. Dynamic Options:**
```typescript
{
  key: 'officeId',
  label: 'Office',
  type: 'select',
  options: {
    dynamic: {
      resource: 'office',         // Load from office resource
      valueField: 'id',           // Use id as value
      labelField: 'name',         // Use name as label
      filter: (office) => office.isActive,  // Only active offices
      sort: 'name'                // Sort by name
    }
  }
}
```

### **Relationship Modeling**

**One-to-Many:**
```typescript
relationships: {
  orders: {
    type: 'one-to-many',
    relatedEntity: 'orders',
    foreignKey: 'customerId',       // Field on Order model
    displayInDetail: true,          // Show in customer detail view
    cascadeDelete: false            // Don't delete orders when customer deleted
  }
}
```

**Many-to-One:**
```typescript
relationships: {
  office: {
    type: 'many-to-one',
    relatedEntity: 'offices',
    foreignKey: 'officeId',         // Field on Customer model
    displayInForm: true,            // Show office selector in forms
    displayInTable: true,           // Show office column in tables
    displayInDetail: true           // Show office info in detail view
  }
}
```

**Many-to-Many:**
```typescript
relationships: {
  tags: {
    type: 'many-to-many',
    relatedEntity: 'tags',
    junctionTable: 'customer_tags', // Junction table name
    displayInDetail: true           // Show tags in detail view
  }
}
```

---

## Database Integration

### **Required Prisma Model Fields**

Every model must include these system fields:

```prisma
model YourModel {
  // Your custom fields here...
  
  // ============================================================================
  // REQUIRED SYSTEM FIELDS
  // ============================================================================
  
  // Multi-tenant support (required)
  tenantId    String
  branchId    String
  
  // Branching system (required for Copy-on-Write)
  originalYourModelId String?
  originalYourModel   YourModel? @relation("BranchVersionYourModel", fields: [originalYourModelId], references: [id])
  branchedYourModels  YourModel[] @relation("BranchVersionYourModel")
  
  // Timestamps (recommended)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Audit fields (optional)
  createdById String?
  updatedById String?
  
  // Required indexes (critical for performance)
  @@index([branchId])
  @@index([tenantId, branchId])
  
  // Your custom indexes here...
  @@map("your_table_name")
}
```

### **Junction Tables**

For many-to-many relationships, create junction tables:

```prisma
// Junction table for Customer ‚Üî Tag relationship
model CustomerTag {
  id         String   @id @default(cuid())
  customerId String
  tagId      String
  
  // System fields
  tenantId   String
  branchId   String
  createdAt  DateTime @default(now())
  
  // Relationships
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  // Unique constraint
  @@unique([customerId, tagId])
  @@index([branchId])
  @@index([tenantId, branchId])
  @@map("customer_tags")
}
```

### **Migration Best Practices**

```bash
# Create migration
npx prisma migrate dev --name add-customers

# Push changes (development)
npx prisma db push

# Generate client
npx prisma generate

# Reset database (development only)
npx prisma migrate reset
```

---

## Testing Your Resource

### **1. Basic CRUD Testing**

```typescript
// Test file: src/__tests__/customers.test.tsx
import { renderHook, waitFor } from '@testing-library/react';
import { useActionQuery, useActionAPI } from '@/hooks/use-action-api';

describe('Customer Resource', () => {
  it('loads customers', async () => {
    const { result } = renderHook(() => useActionQuery('customer.list'));
    
    await waitFor(() => {
      expect(result.current.data).toBeDefined();
      expect(result.current.isLoading).toBe(false);
    });
  });

  it('creates customer', async () => {
    const { result } = renderHook(() => useActionAPI('customer'));
    
    const customerData = {
      name: 'Test Customer',
      email: 'test@example.com',
      type: 'individual'
    };

    await waitFor(async () => {
      const response = await result.current.createCustomer(customerData);
      expect(response.data.name).toBe('Test Customer');
    });
  });
});
```

### **2. Component Testing**

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { AutoTable } from '@/components/auto-generated';

describe('Customer AutoTable', () => {
  it('renders customer table', () => {
    render(<AutoTable resourceKey="customers" />);
    
    expect(screen.getByRole('table')).toBeInTheDocument();
    expect(screen.getByText('Customer Name')).toBeInTheDocument();
    expect(screen.getByText('Email Address')).toBeInTheDocument();
  });

  it('handles row click', async () => {
    const mockRowClick = jest.fn();
    
    render(
      <AutoTable 
        resourceKey="customers" 
        onRowClick={mockRowClick}
      />
    );
    
    const firstRow = await screen.findByTestId('table-row-0');
    fireEvent.click(firstRow);
    
    expect(mockRowClick).toHaveBeenCalled();
  });
});
```

### **3. Schema Validation Testing**

```typescript
import { CUSTOMER_SCHEMA } from '@/features/customers/customers.schema';
import { validateResourceSchema } from '@/lib/resource-system/validation';

describe('Customer Schema', () => {
  it('has valid schema structure', () => {
    expect(() => validateResourceSchema(CUSTOMER_SCHEMA)).not.toThrow();
  });

  it('has required system fields', () => {
    const requiredFields = ['id', 'tenantId', 'branchId'];
    const schemaFields = CUSTOMER_SCHEMA.fields.map(f => f.key);
    
    requiredFields.forEach(field => {
      expect(schemaFields).toContain(field);
    });
  });

  it('has mobile configuration for all fields', () => {
    CUSTOMER_SCHEMA.fields.forEach(field => {
      expect(field.mobile).toBeDefined();
      expect(field.mobile.priority).toBeDefined();
      expect(field.mobile.displayFormat).toBeDefined();
    });
  });
});
```

---

## Advanced Features

### **1. Custom Actions**

Add custom business logic:

```typescript
// In schema
actions: {
  custom: [
    {
      id: 'sendWelcomeEmail',
      label: 'Send Welcome Email',
      handler: 'sendCustomerWelcomeEmail',
      optimistic: false  // Requires server confirmation
    }
  ]
}

// Server handler: src/lib/server/handlers/customer-handlers.ts
export async function sendCustomerWelcomeEmail(
  data: { customerId: string },
  context: ExecutionContext
) {
  const customer = await prisma.customer.findUnique({
    where: { id: data.customerId }
  });
  
  if (!customer?.email) {
    throw new Error('Customer has no email address');
  }
  
  await sendEmail({
    to: customer.email,
    subject: 'Welcome!',
    template: 'customer-welcome',
    data: { customerName: customer.name }
  });
  
  return { success: true, message: 'Welcome email sent' };
}

// Usage
const { customAction } = useActionAPI('customer');
await customAction('sendWelcomeEmail', { customerId: 'cust123' });
```

### **2. Field Dependencies**

Create fields that depend on other field values:

```typescript
{
  key: 'businessName',
  label: 'Business Name',
  type: 'text',
  // Show only when type is 'business' or 'enterprise'
  showWhen: (formData) => ['business', 'enterprise'].includes(formData.type),
  required: (formData) => formData.type === 'business',
  validation: [
    {
      type: 'custom',
      message: 'Business name required for business customers',
      validator: (value, formData) => {
        if (formData.type === 'business' && !value) {
          return false;
        }
        return true;
      }
    }
  ]
}
```

### **3. Computed Fields**

Add fields computed from other fields:

```typescript
{
  key: 'displayName',
  label: 'Display Name',
  type: 'text',
  computed: true,
  computeValue: (formData) => {
    if (formData.company) {
      return `${formData.name} (${formData.company})`;
    }
    return formData.name;
  },
  mobile: { priority: 'high', displayFormat: 'text' },
  desktop: { showInTable: true, tableWidth: 'lg' }
}
```

### **4. Custom Validation**

Add complex validation rules:

```typescript
{
  key: 'email',
  label: 'Email',
  type: 'email',
  validation: [
    { type: 'required', message: 'Email is required' },
    { type: 'email', message: 'Must be valid email' },
    {
      type: 'custom',
      message: 'Email already exists',
      validator: async (value, formData, context) => {
        // Async validation - check if email exists
        const existing = await context.actionClient.executeAction({
          action: 'customer.list',
          data: { email: value }
        });
        
        // Allow current customer to keep their email
        return existing.data.length === 0 || 
               existing.data[0].id === formData.id;
      }
    }
  ]
}
```

---

## Common Patterns

### **1. Hierarchical Resources**

For nested resources like categories:

```typescript
const CATEGORY_SCHEMA: ResourceSchema = {
  databaseKey: 'categories',
  modelName: 'Category', 
  actionPrefix: 'category',
  
  fields: [
    {
      key: 'parentId',
      label: 'Parent Category',
      type: 'select',
      autoValue: { source: 'context.parentId' }, // Auto-populate from navigation
      options: {
        dynamic: {
          resource: 'category',
          valueField: 'id',
          labelField: 'name',
          filter: (item) => item.id !== formData.id // Prevent self-reference
        }
      }
    },
    {
      key: 'level',
      label: 'Level',
      type: 'number',
      computed: true,
      computeValue: (formData) => {
        // Compute level based on parent
        return formData.parent ? formData.parent.level + 1 : 0;
      }
    },
    {
      key: 'path',
      label: 'Path',
      type: 'json',
      computed: true,
      computeValue: (formData) => {
        // Build hierarchy path
        const path = formData.parent ? [...formData.parent.path] : [];
        path.push(formData.id);
        return path;
      }
    }
  ]
};
```

### **2. Status Workflow Resources**

For resources with status transitions:

```typescript
const ORDER_SCHEMA: ResourceSchema = {
  fields: [
    {
      key: 'status',
      label: 'Order Status',
      type: 'select',
      options: {
        static: [
          { value: 'draft', label: 'Draft' },
          { value: 'submitted', label: 'Submitted' },
          { value: 'processing', label: 'Processing' },
          { value: 'shipped', label: 'Shipped' },
          { value: 'delivered', label: 'Delivered' },
          { value: 'cancelled', label: 'Cancelled' }
        ]
      },
      // Validation for status transitions
      validation: [
        {
          type: 'custom',
          message: 'Invalid status transition',
          validator: (newStatus, formData) => {
            const validTransitions = {
              'draft': ['submitted', 'cancelled'],
              'submitted': ['processing', 'cancelled'],
              'processing': ['shipped', 'cancelled'],
              'shipped': ['delivered'],
              'delivered': [],
              'cancelled': []
            };
            
            const currentStatus = formData.originalStatus || 'draft';
            return validTransitions[currentStatus].includes(newStatus);
          }
        }
      ]
    }
  ],
  
  actions: {
    custom: [
      {
        id: 'submit',
        label: 'Submit Order',
        handler: 'submitOrder'
      },
      {
        id: 'cancel',
        label: 'Cancel Order', 
        handler: 'cancelOrder'
      }
    ]
  }
};
```

### **3. Document Resources**

For resources with file attachments:

```typescript
const DOCUMENT_SCHEMA: ResourceSchema = {
  fields: [
    {
      key: 'file',
      label: 'Document File',
      type: 'file',
      validation: [
        { type: 'required', message: 'Please select a file' },
        {
          type: 'custom',
          message: 'Only PDF, DOC, and DOCX files allowed',
          validator: (file) => {
            const allowedTypes = [
              'application/pdf',
              'application/msword',
              'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            ];
            return allowedTypes.includes(file.type);
          }
        }
      ],
      upload: {
        destination: 'documents/',
        maxSize: 10 * 1024 * 1024,  // 10MB
        generateFileName: (file, data) => 
          `${data.name}_${Date.now()}.${file.extension}`
      }
    },
    {
      key: 'fileUrl',
      label: 'File URL',
      type: 'text',
      computed: true,
      computeValue: (formData) => formData.file?.url
    },
    {
      key: 'fileSize',
      label: 'File Size',
      type: 'number',
      computed: true,
      computeValue: (formData) => formData.file?.size
    }
  ]
};
```

---

## Troubleshooting

### **Common Issues**

**1. ‚ùå "No Prisma configuration found for model: [ModelName]"**
```bash
üî• [CreateHandler] PrismaService.create failed
Error: No Prisma configuration found for model: DataTable
```
**Root Cause:** Missing `PRISMA_FIELD_CONFIG` entry in `prisma-data-factory.ts`

**Solution:** Add your model to the configuration:
```typescript
// src/lib/server/prisma/prisma-data-factory.ts
const PRISMA_FIELD_CONFIG = {
  // ... existing models
  DataTable: {
    nullableWithDefaults: ['description', 'config'],
    relationships: {
      tenantId: 'tenant',
      branchId: 'branch',
      categoryId: 'category',
      createdById: 'createdBy',
      updatedById: 'updatedBy'
    },
    required: ['id', 'name'],
    autoGenerated: ['id', 'createdAt', 'updatedAt', 'version']
  }
} as const;
```

**2. Schema not recognized:**
```bash
Error: Resource not found: customers
```
**Solution:** Make sure schema is imported and added to `SCHEMA_RESOURCES` array.

**3. TypeScript errors:**
```bash
Error: Property 'customers' does not exist on type 'ResourceRegistry'
```
**Solution:** Run `npm run dev` to regenerate types, or restart TypeScript server.

**4. Database errors:**
```bash
Error: Unknown argument `customerId` in selection set
```
**Solution:** Run `npx prisma generate` after updating Prisma schema.

**4. Missing fields in forms:**
```typescript
// Fields not showing in AutoForm
// Check mobile configuration:
mobile: { priority: 'high', displayFormat: 'text' }  // ‚úÖ Will show
mobile: { priority: 'low', displayFormat: 'hidden' } // ‚ùå Won't show
```

**5. Cache issues:**
```typescript
// Clear cache after schema changes
import { useActionCache } from '@/hooks/use-action-api';

const { clear } = useActionCache();
clear(); // Clears all cached data
```

### **Debug Tools**

**1. Schema Validation:**
```typescript
import { validateResourceSchema } from '@/lib/resource-system/validation';

try {
  validateResourceSchema(CUSTOMER_SCHEMA);
  console.log('Schema is valid');
} catch (error) {
  console.error('Schema validation failed:', error.message);
}
```

**2. Action Registry Debug:**
```typescript
import { getActionMappings } from '@/lib/resource-system/resource-registry';

const mappings = getActionMappings();
console.log('Available actions:', Object.keys(mappings));
console.log('Customer actions:', Object.keys(mappings).filter(k => k.startsWith('customer.')));
```

**3. Performance Monitoring:**
```typescript
const { data, executionTime, fromCache } = useActionQuery('customer.list');

console.log({
  executionTime: `${executionTime}ms`,
  fromCache: fromCache ? 'IndexedDB' : 'Server',
  performance: executionTime < 50 ? 'Fast' : 'Slow'
});
```

---

## Next Steps

- **[Server Integration](./07-server-integration.md)** - Understand the backend routing
- **[Performance Optimization](./08-performance-optimization.md)** - Advanced performance techniques
- **[Best Practices](./09-best-practices.md)** - Development patterns and guidelines

You now have a **complete, production-ready resource** with:
- ‚úÖ Full CRUD operations with optimistic updates
- ‚úÖ Mobile-first responsive UI components  
- ‚úÖ Type-safe API with validation
- ‚úÖ Performance optimized with caching
- ‚úÖ Branch-aware versioning
- ‚úÖ Auto-generated documentation

**The power of schema-driven development means you can add complex features in minutes, not days!** 